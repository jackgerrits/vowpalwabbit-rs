/* automatically generated by rust-bindgen 0.60.1 */

pub const _LIBCPP_VERSION: u32 = 14000;
pub const _LIBCPP_ABI_VERSION: u32 = 1;
pub const _LIBCPP_STD_VER: u32 = 14;
pub const _LIBCPP_OBJECT_FORMAT_MACHO: u32 = 1;
pub const _LIBCPP_HIDE_FROM_ABI_PER_TU: u32 = 0;
pub const _LIBCPP_DEBUG_LEVEL: u32 = 0;
pub const _LIBCPP_LOCALE__L_EXTENSIONS: u32 = 1;
pub const __cpp_lib_chrono_udls: u32 = 201304;
pub const __cpp_lib_complex_udls: u32 = 201309;
pub const __cpp_lib_exchange_function: u32 = 201304;
pub const __cpp_lib_generic_associative_lookup: u32 = 201304;
pub const __cpp_lib_integer_sequence: u32 = 201304;
pub const __cpp_lib_integral_constant_callable: u32 = 201304;
pub const __cpp_lib_is_final: u32 = 201402;
pub const __cpp_lib_is_null_pointer: u32 = 201309;
pub const __cpp_lib_make_reverse_iterator: u32 = 201402;
pub const __cpp_lib_make_unique: u32 = 201304;
pub const __cpp_lib_null_iterators: u32 = 201304;
pub const __cpp_lib_quoted_string_io: u32 = 201304;
pub const __cpp_lib_result_of_sfinae: u32 = 201210;
pub const __cpp_lib_robust_nonmodifying_seq_ops: u32 = 201304;
pub const __cpp_lib_shared_timed_mutex: u32 = 201402;
pub const __cpp_lib_string_udls: u32 = 201304;
pub const __cpp_lib_transformation_trait_aliases: u32 = 201304;
pub const __cpp_lib_transparent_operators: u32 = 201210;
pub const __cpp_lib_tuple_element_t: u32 = 201402;
pub const __cpp_lib_tuples_by_type: u32 = 201304;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___libcpp_is_integral {
    pub _address: u8,
}
pub const std___libcpp_is_integral_value: std___libcpp_is_integral__bindgen_ty_1 = 0;
pub type std___libcpp_is_integral__bindgen_ty_1 = i32;
#[test]
fn __bindgen_test_layout_std___libcpp_is_integral_open0_bool__close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___libcpp_is_integral>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___libcpp_is_integral)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___libcpp_is_integral>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___libcpp_is_integral)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___libcpp_is_integral_open0_char_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___libcpp_is_integral>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___libcpp_is_integral)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___libcpp_is_integral>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___libcpp_is_integral)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___libcpp_is_integral_open0_signed_char_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___libcpp_is_integral>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___libcpp_is_integral)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___libcpp_is_integral>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___libcpp_is_integral)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___libcpp_is_integral_open0_unsigned_char_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___libcpp_is_integral>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___libcpp_is_integral)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___libcpp_is_integral>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___libcpp_is_integral)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___libcpp_is_integral_open0_wchar_t_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___libcpp_is_integral>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___libcpp_is_integral)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___libcpp_is_integral>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___libcpp_is_integral)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___libcpp_is_integral_open0_char16_t_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___libcpp_is_integral>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___libcpp_is_integral)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___libcpp_is_integral>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___libcpp_is_integral)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___libcpp_is_integral_open0_char32_t_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___libcpp_is_integral>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___libcpp_is_integral)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___libcpp_is_integral>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___libcpp_is_integral)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___libcpp_is_integral_open0_short_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___libcpp_is_integral>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___libcpp_is_integral)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___libcpp_is_integral>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___libcpp_is_integral)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___libcpp_is_integral_open0_unsigned_short_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___libcpp_is_integral>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___libcpp_is_integral)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___libcpp_is_integral>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___libcpp_is_integral)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___libcpp_is_integral_open0_int_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___libcpp_is_integral>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___libcpp_is_integral)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___libcpp_is_integral>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___libcpp_is_integral)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___libcpp_is_integral_open0_unsigned_int_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___libcpp_is_integral>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___libcpp_is_integral)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___libcpp_is_integral>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___libcpp_is_integral)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___libcpp_is_integral_open0_long_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___libcpp_is_integral>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___libcpp_is_integral)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___libcpp_is_integral>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___libcpp_is_integral)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___libcpp_is_integral_open0_unsigned_long_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___libcpp_is_integral>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___libcpp_is_integral)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___libcpp_is_integral>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___libcpp_is_integral)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___libcpp_is_integral_open0_long_long_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___libcpp_is_integral>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___libcpp_is_integral)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___libcpp_is_integral>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___libcpp_is_integral)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___libcpp_is_integral_open0_unsigned_long_long_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___libcpp_is_integral>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___libcpp_is_integral)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___libcpp_is_integral>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___libcpp_is_integral)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___libcpp_is_integral_open0___int128_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___libcpp_is_integral>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___libcpp_is_integral)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___libcpp_is_integral>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___libcpp_is_integral)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___libcpp_is_integral_open0_unsigned___int128_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___libcpp_is_integral>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___libcpp_is_integral)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___libcpp_is_integral>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___libcpp_is_integral)
        )
    );
}
pub type std_nullptr_t = *const ::std::os::raw::c_void;
pub type size_t = ::std::os::raw::c_ulong;
pub type max_align_t = f64;
pub const VW_STATUS_SUCCESS: ::std::os::raw::c_int = 0;
pub const VW_STATUS_FAIL: ::std::os::raw::c_int = 1;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VWWorkspace {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VWExample {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VWErrorMessage {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VWMultiEx {
    _unused: [u8; 0],
}
extern "C" {
    pub fn VWErrorMessageCreate() -> *mut VWErrorMessage;
}
extern "C" {
    pub fn VWErrorMessageDelete(error_message_handle: *mut VWErrorMessage);
}
extern "C" {
    pub fn VWErrorMessageGetValue(
        error_message_handle: *const VWErrorMessage,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn VWErrorMessageClearValue(error_message_handle: *mut VWErrorMessage);
}
extern "C" {
    #[must_use]
    pub fn VWWorkspaceInitialize(
        tokens: *const *const ::std::os::raw::c_char,
        count: ::std::os::raw::c_int,
        output_handle: *mut *mut VWWorkspace,
        error_message: *mut VWErrorMessage,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn VWWorkspaceDelete(workspace_handle: *mut VWWorkspace);
}
extern "C" {
    #[must_use]
    pub fn VWWorkspaceLearn(
        workspace_handle: *mut VWWorkspace,
        example_handle: *mut VWExample,
        error_message_handle: *mut VWErrorMessage,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[must_use]
    pub fn VWWorkspaceParseDSJson(
        workspace_handle: *mut VWWorkspace,
        json_string: *const ::std::os::raw::c_char,
        length: size_t,
        output_handle: *mut VWMultiEx,
        error_message_handle: *mut VWErrorMessage,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn VWExampleCreate() -> *mut VWExample;
}
extern "C" {
    pub fn VWExampleDelete(example_handle: *mut VWExample);
}
extern "C" {
    pub fn VWMultiExCreate() -> *mut VWMultiEx;
}
extern "C" {
    pub fn VWMultiExDelete(example_handle: *mut VWMultiEx);
}
extern "C" {
    pub fn VWMultiGetLength(example_handle: *mut VWMultiEx) -> size_t;
}
extern "C" {
    #[must_use]
    pub fn VWMultiGetExample(
        example_handle: *mut VWMultiEx,
        examples: *mut *mut VWExample,
        index: size_t,
        error_message_handle: *mut VWErrorMessage,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn VWMultiClear(example_handle: *mut VWMultiEx);
}
